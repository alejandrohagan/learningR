{
  "hash": "c7ad220b441d4dba5d544d4fa798f160",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"many_models\"\n---\n\n\nsource\n\n(https://tim-tiefenbach.de/post/2023-dplyr-many-models/)\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"dplyover\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nInstalling package into '/home/hagan/R/x86_64-pc-linux-gnu-library/4.3'\n(as 'lib' is unspecified)\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: package 'dplyover' is not available for this version of R\n\nA version of this package for your version of R might be available elsewhere,\nsee the ideas at\nhttps://cran.r-project.org/doc/manuals/r-patched/R-admin.html#Installing-packages\n```\n\n\n:::\n\n```{.r .cell-code}\nremotes::install_github(\"TimTeaFan/dplyover\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nSkipping install of 'dplyover' from a github remote, the SHA1 (f0cd9845) has not changed since last install.\n  Use `force = TRUE` to force installation\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(tidyverse)        # <- necessary\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.1\n✔ ggplot2   3.5.0     ✔ tibble    3.2.1\n✔ lubridate 1.9.3     ✔ tidyr     1.3.0\n✔ purrr     1.0.2     \n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(tidyr)        # <- necessary\nlibrary(broom)        # <- necessary\nlibrary(rlang)        # <- nice to have\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\nAttaching package: 'rlang'\n\nThe following objects are masked from 'package:purrr':\n\n    %@%, flatten, flatten_chr, flatten_dbl, flatten_int, flatten_lgl,\n    flatten_raw, invoke, splice\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(modelsummary) # <- for output\nlibrary(purrr)        # <- not really needed\nlibrary(dplyover)     # <- only for the data\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlookup_vec <- set_names(names(csatraw), names(csat))\n\n\n\ncsat_named <- csatraw |>\n  rename(any_of(lookup_vec)) |>\n  select(cust_id, type, product, csat,\n         ends_with(\"rating\"))\n\ncsat_named_nested <- csat_named %>% \n  nest_by(product) %>% \n  mutate(data=list(data))\n\n# make forumla\nlm_fomrula <- my_formula <- csat ~ postal_rating + phone_rating + email_rating +\n  website_rating + shop_rating\n\n#use formula and gather results\ncsat_prod_nested_res <- csat_named_nested %>% \n    mutate(\n      mod = list(lm(my_formula, data = data))\n      ,modstat = list(broom::glance(mod))\n      ,res =     list(broom::tidy(mod))\n      )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncsat_prod_nested_res |>\n  select(product, modstat) |>\n  unnest(modstat) |>\n  select(r.squared, p.value, nobs)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nAdding missing grouping variables: `product`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 4\n# Groups:   product [3]\n  product  r.squared p.value  nobs\n  <chr>        <dbl>   <dbl> <int>\n1 advanced     0.112   0.941    15\n2 basic        0.382   0.192    20\n3 premium      0.185   0.645    21\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncsat_prod_nested_res |>\n  select(product, res) |>\n  unnest(res) |>\n  filter(term != \"(Intercept)\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 15 × 6\n# Groups:   product [3]\n   product  term           estimate std.error statistic p.value\n   <chr>    <chr>             <dbl>     <dbl>     <dbl>   <dbl>\n 1 advanced postal_rating   0.396       0.483   0.819     0.434\n 2 advanced phone_rating   -0.235       0.423  -0.556     0.592\n 3 advanced email_rating    0.349       0.485   0.720     0.490\n 4 advanced website_rating  0.398       0.456   0.874     0.405\n 5 advanced shop_rating    -0.00183     0.288  -0.00637   0.995\n 6 basic    postal_rating  -0.324       0.225  -1.44      0.172\n 7 basic    phone_rating   -0.297       0.237  -1.25      0.231\n 8 basic    email_rating   -0.136       0.249  -0.547     0.593\n 9 basic    website_rating  0.229       0.229   1.00      0.334\n10 basic    shop_rating     0.321       0.259   1.24      0.235\n11 premium  postal_rating   0.0538      0.220   0.245     0.810\n12 premium  phone_rating   -0.508       0.307  -1.65      0.119\n13 premium  email_rating    0.375       0.309   1.22      0.243\n14 premium  website_rating -0.175       0.259  -0.677     0.509\n15 premium  shop_rating     0.0498      0.203   0.246     0.809\n```\n\n\n:::\n:::\n\n\n\n## Advanced features to super charge\n\n\n### How to add a all to different subcomponents\n\n1. For the dimension you are querying add a \"All\" component\n2. pass this to `bind_rows()` to the original dataframe\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncsat_all <- csat_named |>\n  mutate(product = \"All\") |>\n  bind_rows(csat_named) \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncsat_named_nested <- csat_all %>% \n  nest_by(product) %>% \n  mutate(\n    data=list(data)\n    ,mod=list(lm(my_formula,data=data))\n    ,mod2=list(lm(csat~postal_rating,data=data))\n    ,modstat2=list(broom::glance(mod2))\n    ,res=list(broom::tidy(mod))\n    ,modstat=list(broom::glance(mod))\n    )\n\ncsat_named_nested %>% \n  unnest(modstat2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 18\n# Groups:   product [4]\n  product  data     mod    mod2  r.squared adj.r.squared sigma statistic p.value\n  <chr>    <list>   <list> <lis>     <dbl>         <dbl> <dbl>     <dbl>   <dbl>\n1 All      <tibble> <lm>   <lm>   0.000121      -0.00801  1.22   0.0149    0.903\n2 advanced <tibble> <lm>   <lm>   0.0338         0.00259  1.16   1.08      0.306\n3 basic    <tibble> <lm>   <lm>   0.000194      -0.0198   1.20   0.00972   0.922\n4 premium  <tibble> <lm>   <lm>   0.00148       -0.0248   1.25   0.0564    0.814\n# ℹ 9 more variables: df <dbl>, logLik <dbl>, AIC <dbl>, BIC <dbl>,\n#   deviance <dbl>, df.residual <int>, nobs <int>, res <list>, modstat <list>\n```\n\n\n:::\n:::\n\n\n## how to dynamic filter datasets or augmented based on user input  conditions\n\n\n-   Create a list of named arguments that would be passed on filter()\n        -   The names are will be used as row entries later on\n        -   Use `TRUE` to keep all rows (eg no filter)\n        -   If you want to to filter rows / data then you need to use `expr()` to capture the expression that would go directly into filter of the nested dataset\n        -   Write it as if you were directly filtering data in a regular filter, eg  `eval(cut==\"Fair\")`\n\n-   Use `expand_grid()` to create pair of each nested table by the filter criteria\n-   In the framing table use, create a new column with the names (using `names()`) of the list containing the filter object\n-   Create a new column that filters the data set and evaluates the arguments `filter(data,eval(filter_ls))`\n    -    Remember to use `expr()` for non logical arguments\n    -   Alternative you can directly name the column names from the datamodel\n-   When doing additional modling on the data objects, it can be difficult to understand what has been done to each data object\n    -   instead of using `list(lm(my_formula,data=data))` you can use `rlang::list2({product}_{type}:=lm(my_formula,data=data))` which makes it easier to know what is going on \n-   You can nest the formula arguments inside as well by creating a named list for the arguments and directly passing that through\n-   From there you can use `eval()` in `lm()` to execute the arguments\n\n### Add section on how to do it more dynamically with glue::glue and expr()\n\n-   You can use create strings use glue::glue to construct customer arguments\n-   Then use `rlang::parse_expr()`to execute that argument\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter_ls <- list(\n  All = TRUE,\n  no_reactivate = expr(type != \"reactivate\")\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncast_all_groups <- csat_all %>% \n  nest_by(product) %>% \n  mutate(data=list(data)) %>% \n  expand_grid(filter_ls) %>% \n  mutate(\n    type=names(filter_ls)\n    ,.after = product\n    )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnamed_formula <- list2(standard=my_formula <- csat ~ postal_rating + phone_rating + email_rating +\n  website_rating + shop_rating)\ncast_all_groups %>% \n  rowwise() %>% \n  mutate(\n    data=list(\n      filter(data,eval(filter_ls))\n      )\n    ,formula=named_formula\n    ,formula_name=names(named_formula)\n    ,.keep = \"unused\"\n  ) %>% \n  mutate(\n    mod=list2(\"{product}_{type}\":=lm(eval(formula),data=data))\n    ,res=list2(\"{product}_{type}\":=broom::glance(mod))\n  ) %>% unnest(res)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 18\n  product  type    data     formula   formula_name mod   r.squared adj.r.squared\n  <chr>    <chr>   <list>   <named l> <chr>        <nam>     <dbl>         <dbl>\n1 All      All     <tibble> <formula> standard     <lm>      0.134        0.0479\n2 All      no_rea… <tibble> <formula> standard     <lm>      0.180        0.0771\n3 advanced All     <tibble> <formula> standard     <lm>      0.112       -0.381 \n4 advanced no_rea… <tibble> <formula> standard     <lm>      0.330       -0.340 \n5 basic    All     <tibble> <formula> standard     <lm>      0.382        0.161 \n6 basic    no_rea… <tibble> <formula> standard     <lm>      0.465        0.221 \n7 premium  All     <tibble> <formula> standard     <lm>      0.185       -0.0867\n8 premium  no_rea… <tibble> <formula> standard     <lm>      0.156       -0.196 \n# ℹ 10 more variables: sigma <dbl>, statistic <dbl>, p.value <dbl>, df <dbl>,\n#   logLik <dbl>, AIC <dbl>, BIC <dbl>, deviance <dbl>, df.residual <int>,\n#   nobs <int>\n```\n\n\n:::\n:::\n\n\n## Dynamically create formulas with multiple conditions\n\n\n-   reformulate() is alternative way to create a model argument and can be directly used in a lm()\n    \n    -   reformulate(independent_vars,dependent_vars)   \n    \n    \n\n::: {.cell}\n\n```{.r .cell-code}\nlm(\n  reformulate(\n  termlabels = c(\"carat\",\"cut\",\"color\",\"x\")\n  ,response = \"price\"\n  ),data = diamonds\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nlm(formula = reformulate(termlabels = c(\"carat\", \"cut\", \"color\", \n    \"x\"), response = \"price\"), data = diamonds)\n\nCoefficients:\n(Intercept)        carat        cut.L        cut.Q        cut.C        cut^4  \n    1608.81     11041.86      1299.23      -571.01       364.52        49.40  \n    color.L      color.Q      color.C      color^4      color^5      color^6  \n   -1656.57      -773.38       -99.12        97.90      -149.88      -152.48  \n          x  \n   -1232.42  \n```\n\n\n:::\n:::\n\n\n-   Create vector of quoted column names and use expand grid to directly put them in the framing table\n-   From there you can directly reference the names\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nindep_vars <- c(\"postal_rating\",\n                \"phone_rating\",\n                \"email_rating\",\n                \"website_rating\",\n                \"shop_rating\")\ncsat_all %>% \n  nest_by(product) %>% \n  mutate(data=list(data)) %>% \n  expand_grid(filter_ls,indep_vars) %>% \n  mutate(\n    type=names(filter_ls)\n    ,.after = product\n    ) %>% \n  rowwise() %>% \n  mutate(\n    data=list(filter(data,eval(filter_ls)))\n    ,mod=list(lm(reformulate(termlabels=indep_vars,response=\"csat\"),data=data))\n    ,modstat=list(broom::glance(mod))\n  ) %>% unnest(modstat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 40 × 18\n   product type     data     filter_ls  indep_vars mod   r.squared adj.r.squared\n   <chr>   <chr>    <list>   <named li> <chr>      <lis>     <dbl>         <dbl>\n 1 All     All      <tibble> <lgl [1]>  postal_ra… <lm>    1.21e-4      -0.00801\n 2 All     All      <tibble> <lgl [1]>  phone_rat… <lm>    5.48e-2       0.0470 \n 3 All     All      <tibble> <lgl [1]>  email_rat… <lm>    9.69e-5      -0.00778\n 4 All     All      <tibble> <lgl [1]>  website_r… <lm>    9.53e-3       0.00141\n 5 All     All      <tibble> <lgl [1]>  shop_rati… <lm>    5.04e-3      -0.00318\n 6 All     no_reac… <tibble> <language> postal_ra… <lm>    4.82e-4      -0.00972\n 7 All     no_reac… <tibble> <language> phone_rat… <lm>    5.87e-2       0.0488 \n 8 All     no_reac… <tibble> <language> email_rat… <lm>    1.26e-6      -0.00980\n 9 All     no_reac… <tibble> <language> website_r… <lm>    2.41e-2       0.0140 \n10 All     no_reac… <tibble> <language> shop_rati… <lm>    4.21e-3      -0.00605\n# ℹ 30 more rows\n# ℹ 10 more variables: sigma <dbl>, statistic <dbl>, p.value <dbl>, df <dbl>,\n#   logLik <dbl>, AIC <dbl>, BIC <dbl>, deviance <dbl>, df.residual <int>,\n#   nobs <int>\n```\n\n\n:::\n:::\n\n\n-   Real strength is using this in combination with `update()` to dynamically update the arguments to include more and more arguments\n-   Create baseline argument\n-   Create named list of updated vars that you want to incremental add to argument\n-   Create column of named arguments\n-   use pattern update(base_formula,reformulate(c(\".\",update_vars)\n    -   \".\" says to take all original variables and ad c() and update vars to them\n    -   NULL is wont update anything and is the baseline model\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_formula2 <- csat ~ postal_rating + phone_rating + shop_rating\n\nupdate_vars <- list2(base = NULL,\n                    email = \"email_rating\",\n                    website = \"website_rating+email_rating\")\n\n\ntest <- csat_all %>% \n  nest_by(product) %>% \n  mutate(data=list(data)) %>% \n  expand_grid(filter_ls,update_vars) %>% \n  mutate(\n    type=names(filter_ls)\n    ,args=names(update_vars)\n    ,.after = type\n    ) %>% \n  rowwise() %>% \n  mutate(\n    form=list(\n      update(my_formula2,reformulate(c(\".\",update_vars),intercept = 0))\n    )\n    ,mod=list(\n      lm(form,data=data)\n    )\n    ,modstat=list(\n      broom::glance(mod)\n    )\n  ) %>% \n  unnest(modstat)\n\nhead(test$form)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\ncsat ~ postal_rating + phone_rating + shop_rating - 1\n\n[[2]]\ncsat ~ postal_rating + phone_rating + shop_rating + email_rating - \n    1\n\n[[3]]\ncsat ~ postal_rating + phone_rating + shop_rating + website_rating + \n    email_rating - 1\n\n[[4]]\ncsat ~ postal_rating + phone_rating + shop_rating - 1\n\n[[5]]\ncsat ~ postal_rating + phone_rating + shop_rating + email_rating - \n    1\n\n[[6]]\ncsat ~ postal_rating + phone_rating + shop_rating + website_rating + \n    email_rating - 1\n```\n\n\n:::\n:::\n\n\n# Alternative pattern, Data-less grids\n\n- when you have a column shares a name in the grid and in the underlying datamodel, you can use the .env$col_name to clarify which context you are referring to things \n\n\n::: {.cell}\n\n```{.r .cell-code}\nproduct <- c(\n  \"All\", unique(csat_named$product)\n)\n\nall_grps_grid <- expand_grid(product, filter_ls) |>\n  mutate(type = names(filter_ls),\n         .after = product)\n```\n:::\n\n\n\n## Practice\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nfilter_args <- rlang::list2(All=TRUE,\n                     low_price=expr(price<2000)\n                     ,med_price=expr(price>2000&price<12000)\n                     ,high_price=expr(price>12000)\n                     )\n\n\ndiamonds %>% \n  mutate(color=\"All\") %>% \n  bind_rows(diamonds) %>% \n  nest_by(color) %>% \n  mutate(data=list(data)) %>% \n  expand_grid(filter_args) %>% \n  mutate(\n    filter_names=names(filter_args)\n    ) %>% \n  rowwise() %>% \n  mutate(\n    data=list(filter(data,eval(filter_args)))\n    ,.keep = \"unused\"\n  ) %>% \n  mutate(\n    cor=list(cor(data$carat,data$price))\n    ) %>% \n  unnest(cor) %>% \n  select(color,filter_names,cor) %>% \n  # pivot_wider(names_from=filter_names,values_from=cor) %>% \n  echarts4r::e_charts(x=filter_names) %>% \n  echarts4r::e_scatter(serie =cor,legend = TRUE) %>% \n  # echarts4r::e_scatter(serie =low_price,symbol_size = 10) %>% \n  # echarts4r::e_scatter(serie =high_price,symbol_size = 10) %>% \n  echarts4r::e_visual_map(cor)\n```\n\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"echarts4r html-widget html-fill-item\" id=\"htmlwidget-fe7c73b62d9c41cda92d\" style=\"width:100%;height:500px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-fe7c73b62d9c41cda92d\">{\"x\":{\"theme\":\"\",\"tl\":false,\"draw\":true,\"renderer\":\"canvas\",\"events\":[],\"buttons\":[],\"opts\":{\"yAxis\":[{\"show\":true}],\"xAxis\":[{\"data\":[\"All\",\"low_price\",\"med_price\",\"high_price\"],\"type\":\"category\",\"boundaryGap\":true}],\"legend\":{\"data\":[\"cor\"]},\"series\":[{\"data\":[{\"value\":[\"All\",\"0.9215913\"]},{\"value\":[\"low_price\",\"0.8393688\"]},{\"value\":[\"med_price\",\"0.8076029\"]},{\"value\":[\"high_price\",\"0.3557729\"]},{\"value\":[\"All\",\"0.9007411\"]},{\"value\":[\"low_price\",\"0.8702921\"]},{\"value\":[\"med_price\",\"0.8063140\"]},{\"value\":[\"high_price\",\"0.1984281\"]},{\"value\":[\"All\",\"0.9143402\"]},{\"value\":[\"low_price\",\"0.8622404\"]},{\"value\":[\"med_price\",\"0.8055411\"]},{\"value\":[\"high_price\",\"0.4890331\"]},{\"value\":[\"All\",\"0.9114257\"]},{\"value\":[\"low_price\",\"0.8368706\"]},{\"value\":[\"med_price\",\"0.7963028\"]},{\"value\":[\"high_price\",\"0.4761619\"]},{\"value\":[\"All\",\"0.9289796\"]},{\"value\":[\"low_price\",\"0.8321292\"]},{\"value\":[\"med_price\",\"0.8080878\"]},{\"value\":[\"high_price\",\"0.4665639\"]},{\"value\":[\"All\",\"0.9419823\"]},{\"value\":[\"low_price\",\"0.8705616\"]},{\"value\":[\"med_price\",\"0.8645568\"]},{\"value\":[\"high_price\",\"0.4438310\"]},{\"value\":[\"All\",\"0.9518454\"]},{\"value\":[\"low_price\",\"0.9228768\"]},{\"value\":[\"med_price\",\"0.9129658\"]},{\"value\":[\"high_price\",\"0.4093528\"]},{\"value\":[\"All\",\"0.9523547\"]},{\"value\":[\"low_price\",\"0.9562082\"]},{\"value\":[\"med_price\",\"0.9122147\"]},{\"value\":[\"high_price\",\"0.5354336\"]}],\"name\":\"cor\",\"type\":\"scatter\",\"symbol\":null,\"coordinateSystem\":\"cartesian2d\",\"yAxisIndex\":0,\"xAxisIndex\":0,\"symbolSize\":3}],\"visualMap\":[{\"calculable\":true,\"type\":\"continuous\",\"min\":0.1984280926028189,\"max\":0.9562081672681547}]},\"dispose\":true},\"evals\":[],\"jsHooks\":[]}</script>\n```\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\ncum_sum_vec<- c(\"price\",\"x\",\"y\",\"z\",\"carat\")\n\n input <- \"sum(1:10)\"\n str(expr(input))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n symbol input\n```\n\n\n:::\n\n```{.r .cell-code}\n eval(parse_expr(input))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55\n```\n\n\n:::\n\n```{.r .cell-code}\nargs_lst <- rlang::list2(\n\nrlang::call2('cumsum',expr(price))\n\n  \n  )\n\n\ndiamonds %>% \n  nest_by(cut) %>%\n  mutate(data=list(data)) %>% \n  expand_grid(input_args=cum_sum_vec) %>% \n  mutate(args=glue::glue(\"cumsum({input_args})\")) %>% \n  rowwise() %>% \n  mutate(\n    data_mod=list(\n      mutate(data\n           ,\"{input_args}_cumsum\":=eval(parse_expr(args))\n             )\n      )\n  ) %>% \n\npull(data_mod) %>% .[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,610 × 10\n   carat color clarity depth table price     x     y     z price_cumsum\n   <dbl> <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>        <int>\n 1  0.22 E     VS2      65.1    61   337  3.87  3.78  2.49          337\n 2  0.86 E     SI2      55.1    69  2757  6.45  6.33  3.52         3094\n 3  0.96 F     SI2      66.3    62  2759  6.27  5.95  4.07         5853\n 4  0.7  F     VS2      64.5    57  2762  5.57  5.53  3.58         8615\n 5  0.7  F     VS2      65.3    55  2762  5.63  5.58  3.66        11377\n 6  0.91 H     SI2      64.4    57  2763  6.11  6.09  3.93        14140\n 7  0.91 H     SI2      65.7    60  2763  6.03  5.99  3.95        16903\n 8  0.98 H     SI2      67.9    60  2777  6.05  5.97  4.08        19680\n 9  0.84 G     SI1      55.1    67  2782  6.39  6.2   3.47        22462\n10  1.01 E     I1       64.5    58  2788  6.29  6.21  4.03        25250\n# ℹ 1,600 more rows\n```\n\n\n:::\n:::\n\n\n## Reproduce Stackoverflow posts\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmake_data_fixed <- function(df) {\n\n  df %>% \n    mutate(price_cumsum=cumsum(price),\n           max_price_cumsum=max(price_cumsum))\n}\n\nmake_data_input <- function(df,x) {\n  df %>% \n    mutate(\"{{x}}_cumsum\":=cumsum({{x}}),\n           \"max_{{x}}_cumsum\":=max(\"{{x}}_cumsum\")\n           )\n}\n\nselected_cols <- c(\"clarity\",\"depth\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\ndiamonds %>% \n  nest_by(cut) %>% \n  mutate(data=list(data)) %>% \n  mutate(mod=list(lm(price~carat,data=data)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 3\n# Rowwise:  cut\n  cut       data                  mod   \n  <ord>     <list>                <list>\n1 Fair      <tibble [1,610 × 9]>  <lm>  \n2 Good      <tibble [4,906 × 9]>  <lm>  \n3 Very Good <tibble [12,082 × 9]> <lm>  \n4 Premium   <tibble [13,791 × 9]> <lm>  \n5 Ideal     <tibble [21,551 × 9]> <lm>  \n```\n\n\n:::\n:::\n",
    "supporting": [
      "many_models_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/htmlwidgets-1.6.4/htmlwidgets.js\"></script>\n<script src=\"site_libs/echarts4r-4.8.0/echarts-en.min.js\"></script>\n<script src=\"site_libs/echarts4r-4.8.0/ecStat.min.js\"></script>\n<script src=\"site_libs/echarts4r-4.8.0/dataTool.min.js\"></script>\n<script src=\"site_libs/echarts4r-binding-0.4.5/echarts4r.js\"></script>\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}